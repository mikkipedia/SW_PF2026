<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gunpowder Text Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a; /* Dark ground */
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #controls {
            position: absolute;
            top: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
        }

        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 16px;
            outline: none;
            cursor: pointer;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            background-color: #111; /* Slightly darker canvas background */
            border-radius: 4px;
        }

        /* The Flash Effect Overlay */
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
            transition: opacity 0.1s ease-out;
        }
        
        .flash-active {
            animation: flashAnim 1.5s forwards;
        }

        @keyframes flashAnim {
            0% { opacity: 0; }
            10% { opacity: 0.8; background: #ffaa00; } /* Fiery flash */
            100% { opacity: 0; }
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="wordSelect">Ignite: </label>
        <select id="wordSelect">
            <option value="Gemini">Gemini</option>
            <option value="ChatGPT">ChatGPT</option>
            <option value="Claude">Claude</option>
            <option value="Grok">Grok</option>
        </select>
    </div>

    <div id="flash-overlay"></div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const flashOverlay = document.getElementById('flash-overlay');
        const select = document.getElementById('wordSelect');

        // Configuration
        const config = {
            textScale: 0.18, // Size of text relative to screen
            gunpowderColor: '#555555',
            charredColor: '#0a0a0a',
            fireColor: '#ff6600',
            coreColor: '#ffffcc',
            burnSpeed: 4, // Iterations per frame
            sparkChance: 0.3
        };

        // State
        let particles = [];
        let grid = []; // 2D array storing pixel states: 0=empty, 1=powder, 2=burning, 3=charred
        let burnQueue = []; // Queue of pixels currently on fire
        let width, height;
        let animationId;
        let isFinished = false;

        // Resize handling
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        // --- Particle System for Sparks ---
        class Spark {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
                this.size = Math.random() * 2 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // Gravity
                this.life -= this.decay;
                // Friction
                this.vx *= 0.95;
                this.vy *= 0.95;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.fillStyle = `rgba(255, ${Math.floor(this.life * 200)}, 50, 1)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // --- Initialization ---

        function init(word) {
            cancelAnimationFrame(animationId);
            resize();
            isFinished = false;
            flashOverlay.className = '';
            particles = [];
            burnQueue = [];
            
            // 1. Draw Text to get shapes
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            ctx.font = `bold ${width * config.textScale}px "Courier New", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff'; // Temporary white to read pixels
            ctx.fillText(word, width / 2, height / 2);

            // 2. Read pixels to create the "Gunpowder Grid"
            // We use a lower resolution grid for performance logic, but map to screen pixels
            const imgData = ctx.getImageData(0, 0, width, height);
            const data = imgData.data;
            grid = new Int8Array(width * height).fill(0); // 0: Empty, 1: Powder, 2: Fire, 3: Charred

            let startPixel = -1;

            // Scan to build grid
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    // If pixel is white (part of text)
                    if (data[index] > 50) {
                        grid[y * width + x] = 1; // Mark as Gunpowder
                        
                        // Find the starting point (left-most pixel of the first letter)
                        if (startPixel === -1) {
                            startPixel = y * width + x;
                        }
                    }
                }
            }

            // 3. Ignite the start
            if (startPixel !== -1) {
                burnQueue.push(startPixel);
                grid[startPixel] = 2; // Set to burning
            }

            // Clear canvas for the actual animation
            ctx.clearRect(0,0, width, height);
            
            loop();
        }

        // --- The Burn Logic (Flood Fill) ---
        function updateBurn() {
            // Process the burn queue
            // We process multiple pixels per frame to speed up the burn
            let newSparks = [];
            
            // If queue is empty and we started, we are done
            if (burnQueue.length === 0 && !isFinished) {
                triggerFinale();
                return;
            }

            // We iterate a limited amount to control speed
            let loops = Math.min(burnQueue.length, 200); 
            
            // Randomize index access slightly to make fire look organic
            for(let i = 0; i < loops; i++) {
                // Get a pixel from the "fire front"
                // Using shift() makes it strictly BFS (smooth wave). 
                // Random splicing makes it crackle. Let's mix.
                let indexIdx = Math.floor(Math.random() * Math.min(burnQueue.length, 20));
                let pixelIndex = burnQueue[indexIdx];
                
                // Remove this pixel from queue, it is now burnt
                burnQueue.splice(indexIdx, 1);
                
                grid[pixelIndex] = 3; // Mark as charred

                // Coordinate conversion
                let px = pixelIndex % width;
                let py = Math.floor(pixelIndex / width);

                // Chance to emit spark
                if (Math.random() < config.sparkChance) {
                    newSparks.push(new Spark(px, py));
                }

                // Check Neighbors (Up, Down, Left, Right)
                const neighbors = [
                    pixelIndex + 1,        // Right
                    pixelIndex - 1,        // Left
                    pixelIndex + width,    // Down
                    pixelIndex - width,    // Up
                    pixelIndex + width + 1, // Diag
                    pixelIndex - width - 1
                ];

                for (let n of neighbors) {
                    if (n >= 0 && n < grid.length) {
                        if (grid[n] === 1) { // If Gunpowder
                            grid[n] = 2; // Set to Burning
                            burnQueue.push(n);
                        }
                    }
                }
            }

            particles.push(...newSparks);
        }

        function triggerFinale() {
            isFinished = true;
            flashOverlay.classList.add('flash-active');
            
            // Spawn a burst of particles over the whole text
            for(let y=0; y<height; y+=10) {
                for(let x=0; x<width; x+=10) {
                     if (grid[y * width + x] === 3) { // If charred
                         if(Math.random() > 0.8) particles.push(new Spark(x, y));
                     }
                }
            }
        }

        // --- Rendering ---
        function draw() {
            // Fade out background slightly for trail effect on particles
            ctx.fillStyle = 'rgba(26, 26, 26, 0.4)';
            ctx.fillRect(0, 0, width, height);

            // Draw Gunpowder and Charred Text
            // Note: iterating full pixel grid every frame is heavy. 
            // Optimization: We only draw the updates usually, but here we redraw active areas.
            
            const imageData = ctx.getImageData(0,0, width, height);
            const data = imageData.data;

            // To optimize: We will only manually draw the text pixels onto the buffer
            // However, direct pixel manipulation is fastest here given the grid system.
            
            // Create a temporary buffer for the text layer
            // Actually, let's just use fillRect for valid pixels to allow context blending for glow
            
            // Optimization: Only draw the FIRE. The Gunpowder and Charred stuff can be static?
            // No, the char replaces the gunpowder.
        }

        // Optimized Render Loop
        function loop() {
            updateBurn();

            // Clear screen
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);

            // 1. Draw Static Text State (Gunpowder vs Charred)
            // We iterate the grid. To save performance, in a real engine we'd cache this.
            // For this demo, we will use a "grainy" aesthetic.
            
            const imgData = ctx.createImageData(width, height);
            const buf = new Uint32Array(imgData.data.buffer);
            
            // Colors in ABGR format (little endian)
            const colGunpowder = 0xFF555555; // Gray
            const colCharred = 0xFF000000;   // Black
            const colFire = 0xFF00AAFF;      // Orange/Gold
            
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] === 1) {
                    // Gunpowder with noise
                    if ((i * 1234) % 7 === 0) buf[i] = colGunpowder; 
                } else if (grid[i] === 3) {
                    // Charred
                    buf[i] = colCharred;
                } else if (grid[i] === 2) {
                    // Burning (Active Front)
                    buf[i] = colFire;
                }
            }

            ctx.putImageData(imgData, 0, 0);

            // 2. Add Glow to Burning areas
            // We identify the center of the burn for a glow gradient
            if (burnQueue.length > 0) {
                // Find average position of current fire
                let avgX = 0, avgY = 0;
                let count = 0;
                // Sample every 10th fire pixel to save calc
                for(let i=0; i<burnQueue.length; i+=5) {
                    let idx = burnQueue[i];
                    avgX += idx % width;
                    avgY += Math.floor(idx / width);
                    count++;
                }
                if (count > 0) {
                    avgX /= count;
                    avgY /= count;
                    
                    // Draw Glow
                    const gradient = ctx.createRadialGradient(avgX, avgY, 5, avgX, avgY, 60);
                    gradient.addColorStop(0, 'rgba(255, 150, 0, 1)');
                    gradient.addColorStop(0.4, 'rgba(255, 60, 0, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 60, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    ctx.arc(avgX, avgY, 60, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
            }

            // 3. Update and Draw Sparks
            ctx.globalCompositeOperation = 'lighter';
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw(ctx);
                if (p.life <= 0) particles.splice(i, 1);
            }
            ctx.globalCompositeOperation = 'source-over';

            animationId = requestAnimationFrame(loop);
        }

        // Start
        select.addEventListener('change', (e) => init(e.target.value));
        window.addEventListener('resize', () => init(select.value));
        
        // Initial kick
        init(select.value);

    </script>
</body>
</html>
